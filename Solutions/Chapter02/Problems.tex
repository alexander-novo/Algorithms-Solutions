%!TEX root = ../../Algorithms.tex
\documentclass[Chapter02]{subfiles}

\begin{document}
	\subsection*{Problems}
	\addcontentsline{toc}{subsection}{Problems}

	\begin{enumerate}[leftmargin=\labelsep,label={\textbf{\thesection-\arabic*}}]
		% 2-1
		\item \textbf{\textit{Insertion sort on small arrays in merge sort.}} Although merge sort runes in $\Theta(n \lg(n))$ worst-case time and insertion sort runs in $\Theta(n^2)$ worst-case times, the constant factors in insertion sort can make it faster in practice for small problem sizes on many machines. Thus, it would make sense to \textbf{\textit{coarsen}} the leaves of recursion by using insertion sort within merge sort when subproblems become sufficiently small. Consider a modification to merge sort in which $n / k$ sublists of length $k$ are sorted using insertion sort and then merged using the standard merging mechanism, where $k$ is a value to be determined.
		\begin{enumerate}
			% a.
			\item Show that insertion sort can sort the $n / k$ sublists, each of length $k$, in $\Theta(nk)$ worst-case time.
			\begin{answer}
				Since each sublist is of size $k$, we know sorting each sublist will take $\Theta(k^2)$ worst-case time. Since there are $\frac{n}{k}$ such sublists, the total worst-case sorting time will be $\frac{n}{k} \Theta(k^2) = \Theta(nk)$.
			\end{answer}

			% b.
			\item Show how to merge the sublists in $\Theta(n \lg(n / k))$ worst-case time.
			\begin{answer}
				Following our original analysis of \textsc{Merge-Sort}, we know that the $\lg(n)$ factor comes from the height of the recursion tree. Starting from the bottom of the tree, we cut the number of un-merged arrays (represented by the number of nodes on each level, starting with the leaves) in half by merging them. In the worst-case scenario, the recursion tree is complete, so the number of leaves is a power of 2, and the number of times we can cut a number of nodes $n$ in half is $\lg(n)$. So if we start with $n / k$ un-merged arrays (leaves), the number of times we can cut the number of un-merged arrays in half is $\lg(n / k)$. Therefore, we can merge the sublists in $\Theta(n \lg(n / k))$ worst-case time.
			\end{answer}
			
			% c.
			\item Given that the modified algorithm runs in $\Theta(nk + n\lg(n / k))$ worst-case times, what is the largest value of $k$ as a function of $n$ for which the modified algorithm has the same running time as standard merge sort, in terms of $\Theta$-notation?
			\begin{answer}
				If we choose $k = \Theta(\lg(n))$, then the run time is $\Theta(n\lg(n) + n \lg(n / \lg(n)) = \Theta(n\lg(n))$, since $n / \lg(n) < n$ for $n > 2$. If we choose $k$ any (asymptotically) larger, then our runtime would be worse.
			\end{answer}
			
			% d.
			\item How should we choose $k$ in practice?
			\begin{answer}
				In practice, we shouldn't choose $k$ to be an asymptotic function of $n$, since we are arguing that that \textsc{Insertion-Sort} is better than \textsc{Merge-Sort} for \emph{small} values of $k$, based on the constants which are hidden by the asymptotic notation. In practice, we should pick a constant number for $k$ such that the constants of \textsc{Insertion-Sort} allow better run-time than the constants of \textsc{Merge-Sort}. This can be figured out with a more in-depth analysis of the two algorithms, without asymptotic notation, or through trial-and-error on an actual machine.
			\end{answer}
			
		\end{enumerate}

		% 2-2
		\item \textbf{\textit{Correctness of bubblesort.}} Bubblesort is a popular, but inefficient, sorting algorithm. It works by repeatedly swapping adjacent elements that are out of order.

		\begin{algorithm}[H]
			\SetKwProg{Fn}{def}{\string:}{end}
			\SetKwFunction{FSort}{Bubblesort}
			\SetKwFunction{FSwap}{Swap}

			\Fn{\FSort{$A[1 \dots n]$}}{
				\For{$i \leftarrow 1\ \KwTo\ n - 1$}{
					\For{$j \leftarrow n\ \KwTo\ i + 1$}{
						\If{$A[j] < A[j - 1]$}{
							\FSwap{$A[j], A[j - 1]$}\;
						}
					}
				}
			}
		\end{algorithm}
		\begin{enumerate}
			% a.
			\item Let $A'$ denote the output of \textsc{Bubblesort($A$)}. To prove that \textsc{Bubblesort} is correct, we need to prove that it terminates and that
			\begin{equation}
				A'[1] \leq A'[2] \leq \dots \leq A'[n], \label{eq:ch02-bubble-inequality}
			\end{equation}
			where $n$ is the length of $A$. In order to show that \textsc{Bubblesort} actually sorts, what else do we need to prove?
			\begin{answer}
				We need to prove that $A'$ is a permutation of $A$.
			\end{answer}
		\end{enumerate}

		The next two parts will prove inequality \ref{eq:ch02-bubble-inequality}.

		\begin{enumerate}[resume]
			% b.
			\item State precisely a loop invariant for the \textbf{for} loop in lines 3-7, and prove that this loop invariant holds. Your proof should use the structure of the loop invariant proof presented in this chapter. \label{exer:ch02-bubble-part-b}
			\begin{answer}
				We use the following loop invariant:
				\begin{addmargin}[2em]{2em}
					At the start of each iteration of the \textbf{for} loop of lines 3-7, the element $A[j] \leq A[m]$ for all $j + 1 \leq m \leq n$.
				\end{addmargin}

				We then prove this loop invariant using the structure presented in this chapter:
				\begin{description}
					\item[Initialization:] This is trivially true, since $j + 1 = n + 1$, so there is no such $m$.

					\item[Maintenance:] We have two cases:
					\begin{description}
						\item[Case 1:] $A[j - 1] > A[j]$. Then we swap elements, and we know now that $A[j - 1] < A[j]$. So $A[j - 1] < A[m]$ for $j \leq m \leq n$.
						\item[Case 2:] $A[j - 1] \leq A[j]$. Then $A[j - 1] \leq A[j] \leq A[m]$ for all $j \leq m \leq n$.
					\end{description}

					\item[Termination:] Since the loop terminates when $j = i$, then $A[i] \leq A[m]$ for all $i + 1 \leq m \leq n$. In other words, $A[i]$ is the minimum element of the sub-array $A[i \dots n]$.
				\end{description}
			\end{answer}
			
			% c.
			\item Using the termination condition of the loop invariant prove in part \ref{exer:ch02-bubble-part-b}, state a loop invariant for the \textbf{for} loop in lines 1-8 that will allows you to prove inequality \eqref{eq:ch02-bubble-inequality}. Your proof should use the structure of the loop invariant proof presented in this chapter.
			\begin{answer}
				We use the following loop invariant:
				\begin{addmargin}[2em]{2em}
					At the start of each iteration of the \textbf{for} loop of lines 2-8,
					\begin{equation}
						A'[1] \leq A'[2] \leq \dots \leq A'[i] \leq A'[m], \label{eq:ch02-bubble-invariant-inequality}
					\end{equation}
					for all $i + 1 \leq m \leq n$.
				\end{addmargin}

				We then prove this loop invariant using the structure presented in this chapter:
				\begin{description}
					\item[Initialization:] This is trivially true, since $i = 0$, so inequality \eqref{eq:ch02-bubble-invariant-inequality} is empty.

					\item[Maintenance:] From inequality \eqref{eq:ch02-bubble-invariant-inequality} above, we have for $m = i + 1$,
					\[
						A'[1] \leq A'[2] \leq \dots \leq A'[i] \leq A'[i + 1],
					\]
					and from the loop invariant in problem \ref{exer:ch02-bubble-part-b} above, we have $A'[i + 1] \leq A[m]$ for all $i + 2 \leq m \leq n$.

					\item[Termination:] Since the loop terminates when $i = n$, inequality \eqref{eq:ch02-bubble-inequality} follows directly from inequality \eqref{eq:ch02-bubble-invariant-inequality}.
				\end{description}
			\end{answer}
			
			% d.
			\item What is the worst-case running time of bubblesort? How does it compare to the running time of insertion sort?
			\begin{answer}
				
			\end{answer}
			
		\end{enumerate}
		
		% 2-3
		\item \textbf{\textit{Correctness of Horner's rule.}} The following code fragment implements Horner's rule for evaluating a polynomial
		\begin{align*}
			P(x) &= \sum_{k = 0}^n a_kx^k\\
				&= a_0 + x(a_1 + x(a_2 + \dots + x(a_{n - 1} + xa_n) \dots)),
		\end{align*}
		given the coefficients $a_0, a_1, \dots, a_n$ and a value for $x$:

		\begin{algorithm}[H]
			$y \leftarrow 0$\;
			\For{$i \leftarrow n\ \KwTo\ 0$}{
				$y \leftarrow a_i + x \cdot y$\;
			}
		\end{algorithm}
		\begin{enumerate}
			% a.
			\item In terms of $\Theta$-notation, what is the running time of this code fragment for Horner's rule?
			\begin{answer}
				
			\end{answer}

			% b.
			\item Write pseudocode to implement the naive polynomial-evaluation algorithm that computes each term of the polynomial from scratch. What is the running time of this algorithm? How does it compare to Horner's rule?
			\begin{answer}
				
			\end{answer}
			
			% c.
			\item Consider the following loop invariant:
			\begin{addmargin}[2em]{2em}
				At the start of each iteration of the \textbf{for} loop of lines 2-4,
				\[
					y = \sum_{k = 0}^{n - (i + 1)} a_{k + i + 1}x^k.
				\]
			\end{addmargin}
			Interpret a summation with no terms as equaling 0. Following the structure of the loop invariant proof presented in this chapter, us the loop invariant to show that, at termination,
			\[
				y = \sum_{k = 0}^n a_kx^k.
			\]
			\begin{answer}
				
			\end{answer}
			
			% d.
			\item Conclude by arguing that the given code fragment correctly evaluates a polynomial characterized by the coefficients $a_0, a_1, \dots, a_n$.
			\begin{answer}
				
			\end{answer}
			
		\end{enumerate}
		
		% 2-4
		\item \textbf{\textit{Inversions.}} Let $A[1 \dots n]$ be an array of $n$ distinct numbers. If $i < j$ and $A[i] > A[j]$, then the pair $(i,j)$ is called an \textbf{\textit{inversion}} of $A$.
		\begin{enumerate}
			% a.
			\item List the five inversions of the array $\langle 2, 3, 8, 6, 1 \rangle$.
			\begin{answer}
				
			\end{answer}

			% b.
			\item What array with elements from the set $\mathbb{n} = \{1, 2, \dots, n\}$ has the most inversions? How many does it have?
			\begin{answer}
				
			\end{answer}
			
			% c.
			\item What is the relationship between the running time of insertion sort and the number of inversion in the input array? Justify your answer.
			\begin{answer}
				
			\end{answer}
			
			% d.
			\item Give an algorithm that determines the number of inversion in any permutation on $n$ elements in $\Theta(n \lg(n))$ worst-case time. (\emph{Hint:} Modify merge sort.)
			\begin{answer}
				
			\end{answer}
			
		\end{enumerate}
		
	\end{enumerate}

\end{document}